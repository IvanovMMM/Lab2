## Отчет по лабораторной работе № 1

#### № группы: `ПМ-2401`

#### Выполнил: `Иванов Михаил Алексеевич`

#### Вариант: `14`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> 1) Программа получает на вход числа N и M. Заполняет массив соответствующей им размерности и считывает чисто Т.
> Однако тк нам предстоит выводить матрицу по спирали, то N=M. Это значит можно избавиться от переменной М.
> 2) Сортирует столбцы по возрастанию точек <T, а при равенстве сравнивает по кол-ву точек >T.
> 3) Выводит наименьшую из самых частовстречающихся температур.
> 4) Выводит элементы "по спирали", начиная со среднего (значит длина сторон матрицы еще гарантированно нечетная).
> 5) Заменяет все элементы матрицы, меньшие, чем Т, на Т.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать 1 число, квадрат этого числа чисел (элементы матрицы) и число для сравнения эл-ов в заданиях 2 и 5.

| Ввод            | Тип                |
|-----------------|--------------------|
| n (Число 1)     | Целоеое число      |
| a (n^2 чисел)   | Вещественные числа |
| t (число n^2+1) | Вещественное число |


#### Данные на выход

Т.к. программа должна вывести значения x, удовлетворяющие условию задачи, то на вывод мы получим
строку, содержащую некое неравенство или сстему неравенств.

| №Задания | Тип       | Значение                                   |
|----------|-----------|--------------------------------------------|
| 2        | n строк   | в зависимости от всех введённых переменных |
| 3        | число     | в зависимости от а                         |
| 4        | n^2 чисел | в зависимости от а                         |
| 5        | n строк   | в зависимости от а и t                     |

### 3. Выбор структуры данных

|                 | название переменной | Тип (в Java) | 
|-----------------|---------------------|--------------|
| n (Число 1)     | `n`                 | `int`        |
| a (матрица)     | `a`                 | `double`     | 
| t (число n^2+1) | `t`                 | `double`     |

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает целое число `n`, формирует матрицу размера n x n, заполняет её вещественными числами и считывает вещественное `t`.

2. **Сортировка:**  
   Программа создает массив `double[][]` размера n x 2 и транспонирует массив `a` -> `tm`. Теперь мы сравниваем не столбцы, а строки `tm`. Создается матрица `ml` несущая в себе информацию о колличестве элементов в строке tm больше/меньше чем t. `tm` сортируется по полученным в `ml` значениям. `tm` танспонируется и записывается в `a`. 

3. **Поиск меньшего из самых частовстречающихся элементов:**
   Создаем массив одномерный `mToRow` со всеми имеющимися в `a` температурами для удобства перебора элементов. Переменная `otv` будет содержать предпологаемый ответ (число из списка `mToRow`), переменная `cnt` - колличество элементов `otv` в списке. Перебираем все элементы, если текущий элемент встречался больше `cnt` раз, или столько же, но сам меньше чем `otv`, берем его как текущий ответ. Так далее до кноца списка `mToRow`.

4. **Вывод по спирали:**  
   Выводит все элемены матрицы `a` начиная со среднего против часовой стрелки по спирали. *сначала строки массива `a` записываются в обратном порядке, а затем выводятся по часовой стрелке. В итоге получается вывод против часовой.

5. **Замена всех температур, меньших чем `t`, на `t`:**  
   Перебор всех элементов матрицы `a`.Если выполняется условие, элемент заменяется на значение `t`. Матрица выводится на экран.

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args){
        //Залание 1
        out.println("Task 1");
        int n = in.nextInt(); //тк в задании 4 требуется вывести таблицу по СПИРАЛИ с ЦЕНТРАЛЬНОГО элемента, можем утверждать, что значения m и n равны => m не нужна (более того n - нечетная)
        double [][] a = new double[n][n]; //массив с которым мы будем работать
        for (int i = 0; i < a.length; i++) { //заполняем массив
            for (int j = 0; j < a[i].length; j++) {
                a[i][j] = in.nextDouble();
            }
        }
        int t = in.nextInt(); //вводим переменную для сравнений
        out.println();

        //Задание 2
        out.println("Task 2");
        double [][] tm = new double[a.length][a[0].length]; //транспонированная матрица (проще работать со строками чем со столбцами)
        for (int i = 0; i<a.length; i++) { //заполняем транспонированную матрицу
            for (int j = 0; j<a[0].length; j++) {
                tm[j][i] = a[i][j];
            }
        }
        double [][] ml = new double[tm.length][2]; //матрица несущая в себе информацию о колличестве элементов в строке tm больше/меньше чем t
        for (int i = 0; i<tm.length; i++) {
            int cntLess = 0, cntMore = 0; //счетчик элементов строки tm больше/меньше t
            for (int j = 0; j<tm[i].length; j++) {
                if (tm[i][j]<t) cntLess++;
                if (tm[i][j]>t) cntMore++;
            }
            ml[i][0] = cntLess; //заполнение массива ml
            ml[i][1] = cntMore; //это тоже
        }
        for (int i = 1; i<ml.length; i++) { //это сортировка вставками
            int j = i;
            while (j>0) {
                if (ml[j-1][0]<ml[j][0] || (ml[j-1][0]==ml[j][0] && ml[j-1][1]<ml[j][1])) { //при выполнении условий для сортировки ml повторяем перестановку в tm
                    double[] s1 = ml[j]; ml[j] = ml[j-1]; ml[j-1] = s1;
                    double[] s2 = tm[j]; tm[j] = tm[j-1]; tm[j-1] = s2;
                    j--;
                } else break;
            }
        }
        for (int i = 0; i<tm.length; i++) {
            for (int j = 0; j<tm[0].length; j++) {
                a[j][i] = tm[tm[0].length-1-i][j];
            }
        }
        for (int i = 0; i < a.length; i++) { //вывод ответа
            for (int j = 0; j < a[i].length; j++) {
                out.print(a[i][j]+" ");
            }
            out.println();
        }
        out.println();

        //Задание 3
        out.println("Task 3");
        double [] mToRow = new double[a.length*a[0].length]; //для удобства запихнем все значения температур из a в одномерный массив
        int cur = 0;
        for (int i = 0; i<a.length; i++) { //заполняем
            for (int j = 0; j<a[i].length; j++) {
                mToRow[cur] = a[i][j];
                cur++;
            }
        }
        double otv = 0; //пойдет в ответ на 4 задание
        int cnt = 0; // счетчик повторений элемента
        for (int i = 0; i<mToRow.length; i++) { //находим наименьший элемент среди наиболее часто повторяющихся элементов
            int cntCur = 0;
            for (int j = 0; j<mToRow.length; j++) {
                if (mToRow[i]==mToRow[j]) cntCur++;
            }
            if (cntCur>cnt || (cnt==cntCur && mToRow[i]<otv)) {otv=mToRow[i];cnt=cntCur;}
        }
        out.println(otv);
        out.println();

        //Задание 4
        out.println("Task 4");

        double [][] ar = new double[a.length][a[0].length];
        for (int i = 0; i<a.length; i++) {
            for (int j = a[i].length-1; j>=0; j--) {
                ar[i][ar[i].length-1-j] = a[i][j];
            }
        }

        double [] spiral = new double[ar.length*ar[0].length]; //одномерный массив для хранения эл-тов а "по спирали"
        int k = 1, sr = ar.length/2, spiralInd = 1; //k - на сколько надо сдвинуть i/j; sr = чтобы понимать гдеБ относительно побочной диагонали мы находимся
        //spiralInd - чтобы заполнять spiral
        int i = sr, j = sr; //для перебора элементов матрицы (начиная со среднего)
        spiral[0] = ar[i][j];
        while (!(i==0 && j==0)) {
            if (i<=sr) {
                for (int x = 0; x<k; x++) {j++; spiral[spiralInd]=ar[i][j]; spiralInd++;}
                for (int x = 0; x<k; x++) {i++; spiral[spiralInd]=ar[i][j]; spiralInd++;}
                k++;
            } else {
                for (int x = 0; x<k; x++) {j--; spiral[spiralInd]=ar[i][j]; spiralInd++;}
                for (int x = 0; x<k; x++) {i--; spiral[spiralInd]=ar[i][j]; spiralInd++;}
                k++;
            }
        }
        for (int x = 1; x<ar[0].length; x++) {spiral[spiralInd]=ar[0][x]; spiralInd++;}
        for (int sp = 0; sp<spiral.length; sp++) out.print(spiral[sp]+" "); //выводим spiral
        out.println("\n");

        //Задание 5
        out.println("Task 5");
        for (int i5 = 0; i5<a.length; i5++) { //просто перебираем
            for (int j5 = 0; j5<a[i5].length; j5++) {
                if (a[i5][j5]<t) a[i5][j5] = t; //если значение меньше то заменяем
            }
        }
        for (int i5 = 0; i5<a.length; i5++) { //выводим
            for (int j5 = 0; j5<a[i5].length; j5++) {
                out.print(a[i5][j5]+" ");
            }
            out.println();
        }
    }
}
```

### 6. Анализ правильности решения

Проанализируем на отдельных примерах работу каждого из 4 заданий.

1. Тест сортировки:

   - **Input**:
       ```
     5
     4 4 4 4 4
     4 4 4 6 5
     4 4 4 6 5
     4 5 6 6 5
     4 6 6 6 5
     5
       ```

   - **Output**:
       ```
     4.0 4.0 4.0 4.0 4.0 
     5.0 6.0 4.0 4.0 4.0
     5.0 6.0 4.0 4.0 4.0
     5.0 6.0 5.0 6.0 4.0
     5.0 6.0 6.0 6.0 4.0
     ```
   Очевидно, столбцы отсортированны верно.


2. Тест поиска меньшего из самых частовстречающихся элементов:

   - **Input**:
       ```
     3
     1 4 4
     5 2 4
     5 5 3
     5
       ```
     *в данном тсете число t не важно

   - **Output**:
       ```
       4.0
       ```
     Верно, чаще всего встречались числа 4 и 5, 4 - меньшее из них и идет в ответ.


3. Тест вывода спиралью:

   - **Input**:
       ```
       3
     9 8 7
     2 1 6
     3 4 5
     3
       ```

   - **После сортировки**:
       ```
     7.0 9.0 8.0 
     6.0 2.0 1.0
     5.0 3.0 4.0
       ```

   - **Output**:
       ```
       2.0 6.0 5.0 3.0 4.0 1.0 8.0 9.0 7.0 
       ```
     Визуально можно определить, что вывод корректен. 

4. Замена эл-тов, меньших `t`,на `t`:

    - **Input**:
        ```
        3
      9 8 7
      2 1 6
      3 4 5
      3
        ```
   - **После сортировки**:
       ```
     7.0 9.0 8.0 
     6.0 2.0 1.0
     5.0 3.0 4.0
       ```
   - **Output**:
       ```
       7.0 9.0 8.0 
     6.0 3.0 3.0
     5.0 3.0 4.0
     ```
     Все числа, меньше трех успешно заменены.

